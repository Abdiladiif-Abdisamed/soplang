// Soplang Computation Benchmark
// This file contains computationally intensive operations to benchmark performance

// ===== FACTORIAL COMPUTATION =====
qor("===== FACTORIAL COMPUTATION =====")

// Recursive factorial function
howl factorial(n) {
    haddii (n <= 1) {
        soo_celi 1
    } haddii_kalena {
        soo_celi n * factorial(n - 1)
    }
}

// Calculate factorials 1 through 20
qor("Calculating factorials 1 through 20:")
ku_celi i min 1 ilaa 20 {
    door result = factorial(i)
    qor("factorial(" + qoraal(i) + ") = " + qoraal(result))
}
qor("") // Empty line

// ===== FIBONACCI SEQUENCE =====
qor("===== FIBONACCI SEQUENCE =====")

// Recursive fibonacci function (intentionally inefficient for benchmarking)
howl fibonacci(n) {
    haddii (n <= 0) {
        soo_celi 0
    } haddii_kale (n == 1) {
        soo_celi 1
    } haddii_kalena {
        soo_celi fibonacci(n - 1) + fibonacci(n - 2)
    }
}

// Calculate fibonacci numbers 1 through 30
qor("Calculating fibonacci numbers 1 through 30:")
ku_celi i min 1 ilaa 30 {
    door result = fibonacci(i)
    qor("fibonacci(" + qoraal(i) + ") = " + qoraal(result))
}
qor("") // Empty line

// ===== PRIME NUMBER CALCULATION =====
qor("===== PRIME NUMBER CALCULATION =====")

// Check if a number is prime
howl isPrime(n) {
    haddii (n <= 1) {
        soo_celi false
    }
    
    haddii (n <= 3) {
        soo_celi true
    }
    
    haddii (n % 2 == 0 || n % 3 == 0) {
        soo_celi false
    }
    
    door i = 5
    inta_ay (i * i <= n) {
        haddii (n % i == 0 || n % (i + 2) == 0) {
            soo_celi false
        }
        i = i + 6
    }
    
    soo_celi true
}

// Find prime numbers up to 1000
qor("Finding prime numbers up to 1000:")
door primes = []
ku_celi i min 2 ilaa 1000 {
    haddii (isPrime(i)) {
        primes.push(i)
    }
}
qor("Found " + qoraal(primes.length()) + " prime numbers.")
qor("First 10 primes: " + qoraal(primes.slice(0, 10)))
qor("Last 10 primes: " + qoraal(primes.slice(primes.length() - 10, primes.length())))
qor("") // Empty line

// ===== MATRIX MULTIPLICATION =====
qor("===== MATRIX MULTIPLICATION =====")

// Create two matrices
door matrix1 = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

door matrix2 = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [10, 11, 12]
]

// Function to multiply matrices
howl multiplyMatrices(a, b) {
    door aRows = a.length()
    door aCols = a[0].length()
    door bRows = b.length()
    door bCols = b[0].length()
    
    haddii (aCols != bRows) {
        qor("Error: Matrices cannot be multiplied - incompatible dimensions")
        soo_celi null
    }
    
    // Initialize result matrix with zeros
    door result = []
    ku_celi i min 0 ilaa aRows - 1 {
        door row = []
        ku_celi j min 0 ilaa bCols - 1 {
            row.push(0)
        }
        result.push(row)
    }
    
    // Perform multiplication
    ku_celi i min 0 ilaa aRows - 1 {
        ku_celi j min 0 ilaa bCols - 1 {
            door sum = 0
            ku_celi k min 0 ilaa aCols - 1 {
                sum = sum + (a[i][k] * b[k][j])
            }
            result[i][j] = sum
        }
    }
    
    soo_celi result
}

// Perform matrix multiplication multiple times for benchmarking
qor("Performing matrix multiplication 100 times:")
door iterations = 100
door startTime = time()

ku_celi i min 1 ilaa iterations {
    door result = multiplyMatrices(matrix1, matrix2)
    
    // Only output the first result to avoid flooding the console
    haddii (i == 1) {
        qor("Result of first multiplication:")
        ku_celi r min 0 ilaa result.length() - 1 {
            qor(qoraal(result[r]))
        }
    }
}

door endTime = time()
door duration = endTime - startTime
qor("Matrix multiplication completed in " + qoraal(duration) + " seconds")
qor("") // Empty line

qor("===== END OF COMPUTATION BENCHMARK =====") 